/*
# [Admin Role &amp; RLS Policy Update]
This migration introduces a role-based access control system to grant full administrative privileges for content management. It creates a new 'admin' role, a function to check for this role, and updates the Row-Level Security (RLS) policies on content tables to allow admins to write data while maintaining public read access.

## Query Description:
- **Creates a `user_roles` table:** This table links users from `auth.users` to specific roles (e.g., 'admin').
- **Creates `is_admin()` function:** A security function to check if the current user has the 'admin' role. This is the core of the new permission system.
- **Updates RLS Policies:** Modifies policies on `cities`, `tehsils`, `locations`, and `phrases` tables.
  - Public `SELECT` access is maintained.
  - `INSERT`, `UPDATE`, `DELETE` are restricted to users with the 'admin' role.
- **Seeds Admin User:** Assigns the 'admin' role to the user with the email 'kartikroyal777@gmail.com'.

This operation is safe and essential for the admin panel to function correctly. It does not risk any existing data.

## Metadata:
- Schema-Category: "Structural"
- Impact-Level: "Low"
- Requires-Backup: false
- Reversible: true

## Structure Details:
- **New Table:** `public.user_roles`
- **New Function:** `public.is_admin()`
- **Altered Tables:** `cities`, `tehsils`, `locations`, `phrases` (RLS policies updated)

## Security Implications:
- RLS Status: Enabled and enhanced.
- Policy Changes: Yes. Policies are now role-based for write operations.
- Auth Requirements: Admin actions now require the user to have the 'admin' role in the `user_roles` table.

## Performance Impact:
- Indexes: A primary key and foreign key index are added to `user_roles`.
- Triggers: None.
- Estimated Impact: Negligible. The `is_admin()` function call adds a minor overhead to write operations, but it is highly optimized.
*/

-- 1. Create a table to store user roles
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, role)
);

COMMENT ON TABLE public.user_roles IS 'Stores roles for users, like "admin".';

-- 2. Enable RLS for the new user_roles table
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- 3. Create a function to check if the current user is an admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN AS $$
DECLARE
  is_admin_user BOOLEAN;
BEGIN
  IF auth.role() = 'service_role' THEN
    RETURN TRUE;
  END IF;
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = auth.uid() AND role = 'admin'
  ) INTO is_admin_user;
  RETURN is_admin_user;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION public.is_admin() IS 'Checks if the currently authenticated user has the "admin" role.';

-- 4. Create RLS policies for user_roles table
-- Admins can manage all roles
CREATE POLICY "Allow admins to manage roles"
ON public.user_roles
FOR ALL
USING (public.is_admin())
WITH CHECK (public.is_admin());

-- Users can see their own roles
CREATE POLICY "Allow users to see their own roles"
ON public.user_roles
FOR SELECT
USING (auth.uid() = user_id);

-- 5. Update RLS policies for content tables
-- CITIES
ALTER TABLE public.cities ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access" ON public.cities;
CREATE POLICY "Allow public read access" ON public.cities FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow admin write access" ON public.cities;
CREATE POLICY "Allow admin write access" ON public.cities FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- TEHSILS
ALTER TABLE public.tehsils ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access" ON public.tehsils;
CREATE POLICY "Allow public read access" ON public.tehsils FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow admin write access" ON public.tehsils;
CREATE POLICY "Allow admin write access" ON public.tehsils FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- LOCATIONS
ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access" ON public.locations;
CREATE POLICY "Allow public read access" ON public.locations FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow admin write access" ON public.locations;
CREATE POLICY "Allow admin write access" ON public.locations FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- PHRASES
ALTER TABLE public.phrases ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access" ON public.phrases;
CREATE POLICY "Allow public read access" ON public.phrases FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow admin write access" ON public.phrases;
CREATE POLICY "Allow admin write access" ON public.phrases FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- NOTIFICATIONS
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access" ON public.notifications;
CREATE POLICY "Allow public read access" ON public.notifications FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow admin write access" ON public.notifications;
CREATE POLICY "Allow admin write access" ON public.notifications FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());


-- 6. Seed the admin user role
-- This will assign the 'admin' role to the specified user.
-- The user must already exist in the auth.users table.
DO $$
DECLARE
  admin_user_id UUID;
BEGIN
  SELECT id INTO admin_user_id FROM auth.users WHERE email = 'kartikroyal777@gmail.com';
  IF admin_user_id IS NOT NULL THEN
    INSERT INTO public.user_roles (user_id, role)
    VALUES (admin_user_id, 'admin')
    ON CONFLICT (user_id, role) DO NOTHING;
  ELSE
    RAISE NOTICE 'Admin user with email kartikroyal777@gmail.com not found. Please create the user first.';
  END IF;
END;
$$;
